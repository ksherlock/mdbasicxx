#!/usr/bin/env ruby -w

require 'optparse'
require 'pathname'
require 'tempfile'
require 'time'

require 'MiniAssembler'


VERSION = "0.0.0"



def build_kludge(header, body)
	tmp = Tempfile.new(['md','.b'], '/tmp')

	tmp.puts "' generated by mdbasic++ #{VERSION}"
	header.each { |x| tmp.puts x }
	tmp.puts 
	body.each { |x| tmp.puts x }

	tmp.flush
	return tmp
end


def argf_each 

	if ARGV.empty?
		yield nil, $stdin
	else
		ARGV.each {|file|
			File.open(file, "r") {|io| yield file, io }
		}
	end
	nil
end

def outfile(explicit, infile, ext)
	return [explicit, File.open(explicit, "w")] if explicit
	return [nil, $stdout] if infile.nil?

	if infile =~ /^(.*)(\.[^\/])$/
		infile = "#{$1}.#{ext}"
	else
		infile = "#{infile}.#{ext}"
	end
	return [infile, File.open(infile, "w")]
end

def process(file, io, header, body)

	m = nil
	errors = 0
	io.each_line {|line|
		line.chomp!

		if m
			if line =~ /^#\s*endasm\s*$/
				data = []
				st = {}
				m.finish(data, st)
				m = nil

				data.each {|x|
					body.push "\t#{x}"
				}

				st.each {| k, v |
					k = k.to_s.upcase 
					header.push "#define #{k} #{v}"
				}
			else
				begin
					m.process(line)
				rescue => e
					puts e
					errors = errors + 1
				end
			end
			next
		end

		case line
		when /^#\s*asm\s*$/
			m = MiniAssembler.new()
		else
			body.push line
		end
	}
	return errors

end


now = Time.now
errors = 0

body = []
header = [
	"#define __MDBASICXX__",
	'#define __DATE__ "' + now.strftime("%b %e %Y") + '"',
	'#define __TIME__ "' + now.strftime("%H:%M:%S") + '"',
]

options = { :verbose => false, :I => [], :o => nil }

op = OptionParser.new do |opts|
	opts.banner = "Usage: mdbasic++ [options] [file]"
	opts.version = VERSION
	opts.release = nil


	opts.on("-D macroname[=value]", "Define a macro") do |x|
		k, v = x.split('=',2)
		if v
			header.push "#define #{k} #{v}"
		else
			header.push "#define #{k}"
		end
	end

	opts.on("-E", "Pre-processor only") do 
		options[:E] = true
	end

	opts.on("-S", "Decompile generated code") do
		options[:S] = true
	end

	opts.on("-I directory", "Specify include path") do |x|
		options[:I].push x
	end

	opts.on("-o outfile", "Specify outfile") do |x|
		options[:o] = x
	end

	opts.on("-O level", OptionParser::DecimalInteger, "Specify optimization level") do |x|
		if x < 0 || x > 2
			warn "Invalid optimization level #{x}"
		else
			header.push "#pragma optimize #{x},2"
		end
	end

	opts.on("-v", "--verbose", "Be verbose") do
		options[:verbose] = true
		header.push "#pragma progress 1"
		header.push "#pragma summary 1"
		header.push "#pragma xref 1,1"
	end

	opts.on('-V', "--version", "Display version") do
		puts opts.ver
		exit 0
	end


	opts.on("--[no-]declare", "Require declarations") do |x|
		header.push "#pragma declare #{x ? 1 : 0}"
	end

	opts.on("--[no-]progress", "Print progress") do |x|
		header.push "#pragma progress #{x ? 1 : 0}"
	end

	opts.on("--[no-]summary", "Print summary") do |x|
		header.push "#pragma summary #{x ? 1 : 0}"
	end

	opts.on("--[no-]xref", "Print Cross References") do |x|
		header.push "#pragma xref #{x ? 1 : 0},#{x ? 1 : 0}"
	end


	opts.on_tail("-h", "--help", "Display help information") do
		puts opts
		exit 0
	end


end

begin
	op.parse!
rescue OptionParser::ParseError => e
	puts e
	puts op
	exit 1
end

if ARGV.length > 1
	puts op.banner
	exit 1
end

argf_each {|infile, io|

	errors = process(infile, io, header, body)

	exit if errors > 0

	tmpfile = build_kludge(header, body)


	if options[:E]
		# pre-processor only.
		tmpfile.rewind
		_, f = outfile(options[:o], infile, 'i')

		f.puts tmpfile.read
		f.close() unless f == $stdout
		exit 0
	end


	# todo -- if -S, write to temp file, save disasm to :o
	sfile = nil
	if options[:S]
		sfile = options[:o]
		options[:o] = nil
	end

	outfile = options[:o]

	outfile = options[:o] || Tempfile.new(['md','.basic'], '/tmp').path
	args = ['iix', 'mdbasic', file.path, '-o', outfile]
	pid = Process.spawn(*args)
	Process.wait(pid)
	if $?.exitstatus > 0
		$stderr.puts "mdbasic++: compile #{infile} failed."
		exit(1)
	end

	if options[:S]
		o = {}
		if sfile o[:out] = options[:S]
		args = ['iix', 'blist', outfile, {}]
		pid = Process.spawn(*args)
		Process.wait(pid)
	end



}

exit 0

