#!/usr/bin/env ruby -w

require 'optparse'
require 'pathname'
require 'tempfile'
require 'time'

require 'MiniAssembler'
require 'Applesoft'
require 'version.rb'

# VERSION = "0.0.7"

def argf_each 

	if ARGV.empty?
		yield nil, $stdin
	else
		ARGV.each {|file|
			File.open(file, "r") {|io| yield file, io }
		}
	end
	nil
end

def replace_ext(path, ext = nil)
	return nil unless path
	ext = ext ? "." + ext : ""

	d = File.dirname(path)
	b = File.basename(path, ".*") + ext

	return b if d == '.'
	return d + File::SEPARATOR + b

end


def build_kludge(io, header, body)

	io.puts "' generated by mdbasic++ #{VERSION}"
	header.each { |x| io.puts x }
	io.puts 
	body.each { |x| io.puts x }

	io.flush
end


def process(file, io, header, body)

	m = nil
	errors = 0
	io.each_line {|line|
		line.chomp!

		if m
			if line =~ /^#\s*endasm\s*$/

				begin

					data = []
					st = {}
					m.finish(data, st)
					data.each {|x|
						body.push "\t#{x}"
					}

					st.each {| k, v |
						k = k.to_s.upcase 
						header.push "#define #{k} #{v}"
					}
				rescue => e
					$stderr.puts line
					$stderr.puts e
					$stderr.puts e.backtrace.first
					errors = errors + 1
				ensure
					m = nil
				end

			else
				begin
					m.process(line)
				rescue => e
					$stderr.puts line
					$stderr.puts e
					$stderr.puts e.backtrace.first
					errors = errors + 1
				end
			end
			next
		end

		case line
		when /^#\s*asm\s*$/
			m = MiniAssembler.new()
		else
			body.push line
		end
	}
	if m
		errors = errors+1
		$stderr.puts "unterminated #asm block"
	end
	return errors

end


now = Time.now
errors = 0

body = []
header = [
	"#define __MDBASICXX__",
	'#define __DATE__ "' + now.strftime("%b %e %Y") + '"',
	'#define __TIME__ "' + now.strftime("%H:%M:%S") + '"',
]

options = { :verbose => false, :I => [], :o => nil }

op = OptionParser.new do |opts|
	opts.banner = "Usage: mdbasic++ [options] [file]"
	opts.version = VERSION
	opts.release = nil


	opts.on("-D macroname[=value]", "Define a macro") do |x|
		k, v = x.split('=',2)
		if v
			header.push "#define #{k} #{v}"
		else
			header.push "#define #{k}"
		end
	end

	opts.on("-E", "Pre-processor only") do 
		options[:E] = true
	end



	opts.on("-I directory", "Specify include path") do |x|
		options[:I].push x
	end

	opts.on("-o outfile", "Specify outfile") do |x|
		options[:o] = x
	end

	opts.on("-O level", OptionParser::DecimalInteger, "Specify optimization level") do |x|
		if x < 0 || x > 2
			warn "Invalid optimization level #{x}"
		else
			header.push "#pragma optimize #{x},2"
		end
	end

	opts.on("-S", "Detokenize generated code") do
		options[:S] = true
	end

	opts.on("--lowercase", "use lowercase display (-S)") do
		options[:"S-lowercase"] = true
	end

	opts.on("--compact", "use compact display (-S)") do
		options[:"S-compact"] = true
	end


	opts.on("-v", "--verbose", "Be verbose") do
		options[:verbose] = true
		header.push "#pragma progress 1"
		header.push "#pragma summary 1"
		header.push "#pragma xref 1,1"
	end

	opts.on('-V', "--version", "Display version") do
		puts opts.ver
		exit 0
	end


	opts.on("--[no-]declare", "Require declarations") do |x|
		header.push "#pragma declare #{x ? 1 : 0}"
	end

	opts.on("--[no-]progress", "Print progress") do |x|
		header.push "#pragma progress #{x ? 1 : 0}"
	end

	opts.on("--[no-]summary", "Print summary") do |x|
		header.push "#pragma summary #{x ? 1 : 0}"
	end

	opts.on("--[no-]xref", "Print Cross References") do |x|
		header.push "#pragma xref #{x ? 1 : 0},#{x ? 1 : 0}"
	end


	opts.on_tail("-h", "--help", "Display help information") do
		puts opts
		exit 0
	end


end

begin
	op.parse!
rescue OptionParser::ParseError => e
	puts e
	puts op
	exit 1
end

if ARGV.length > 1
	puts op.banner
	exit 1
end

argf_each {|inpath, io|

	errors = process(inpath, io, header, body)

	exit if errors > 0

	outfile = nil
	outpath = nil
	case options[:o]
	when nil ;
	when '-' ;
		outfile = $stdout
		outpath = nil
	else
		outpath = options[:o]
		outfile = File.open(options[:o], "w")
	end

	if (inpath == nil) && (outpath == nil)
		options[:S] = true
	end


	efile = nil
	if options[:E]
		efile = outfile || $stdout
	else
		efile = Tempfile.new(['md','.b'], '/tmp')
	end

	build_kludge(efile, header, body)

	if options[:E]
		close efile unless efile == $stdout
		exit 0
	end


	bpath = nil
	bfile = nil

	if options[:S]
		bfile = Tempfile.new(['md', '.bas'], '/tmp', :mode => File::BINARY)
		bpath = bfile.path
	else
		bpath = outpath || replace_ext(inpath, 'bas')
	end

	args = ['iix', 'mdbasic', efile.path, '-o', bpath]
	pid = Process.spawn(*args)
	Process.wait(pid)
	if $?.exitstatus > 0
		$stderr.puts "mdbasic++: compile #{inpath} failed."
		exit 1
	end

	if options[:S]
		# o = {}
		# o[:out] = outfile if outfile
		# args = ['iix', 'blist', bpath]
		# pid = Process.spawn(*args, o)
		# Process.wait(pid)
		# $?.exitstatus not currently correct.

		# bfile will always be set.
		bfile.seek(0)
		format = {}
		format[:compact] = options[:"S-compact"]
		format[:lowercase] = options[:"S-lowercase"]
		list(bfile, outfile, format)
	end

	if bfile then
		bfile.close()
	end
}

exit 0

