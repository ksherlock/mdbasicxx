#!/usr/bin/env ruby -w

require 'optparse'
require 'pathname'
require 'tempfile'
require 'time'

require 'MiniAssembler'


VERSION = "0.0.2"

def argf_each 

	if ARGV.empty?
		yield nil, $stdin
	else
		ARGV.each {|file|
			File.open(file, "r") {|io| yield file, io }
		}
	end
	nil
end

def replace_ext(path, ext = nil)
	return nil unless path
	ext = ext ? "." + ext : ""

	d = File.dirname(path)
	b = File.basename(path, ".*") + ext

	return b if d == '.'
	return d + File::SEPARATOR + b

end


def build_kludge(io, header, body)

	io.puts "' generated by mdbasic++ #{VERSION}"
	header.each { |x| io.puts x }
	io.puts 
	body.each { |x| io.puts x }

	io.flush
end


def process(file, io, header, body)

	m = nil
	errors = 0
	io.each_line {|line|
		line.chomp!

		if m
			if line =~ /^#\s*endasm\s*$/
				data = []
				st = {}
				m.finish(data, st)
				m = nil

				data.each {|x|
					body.push "\t#{x}"
				}

				st.each {| k, v |
					k = k.to_s.upcase 
					header.push "#define #{k} #{v}"
				}
			else
				begin
					m.process(line)
				rescue => e
					$stderr.puts line
					$stderr.puts e
					#$stderr.puts e.backtrace
					errors = errors + 1
				end
			end
			next
		end

		case line
		when /^#\s*asm\s*$/
			m = MiniAssembler.new()
		else
			body.push line
		end
	}
	return errors

end


now = Time.now
errors = 0

body = []
header = [
	"#define __MDBASICXX__",
	'#define __DATE__ "' + now.strftime("%b %e %Y") + '"',
	'#define __TIME__ "' + now.strftime("%H:%M:%S") + '"',
]

options = { :verbose => false, :I => [], :o => nil }

op = OptionParser.new do |opts|
	opts.banner = "Usage: mdbasic++ [options] [file]"
	opts.version = VERSION
	opts.release = nil


	opts.on("-D macroname[=value]", "Define a macro") do |x|
		k, v = x.split('=',2)
		if v
			header.push "#define #{k} #{v}"
		else
			header.push "#define #{k}"
		end
	end

	opts.on("-E", "Pre-processor only") do 
		options[:E] = true
	end



	opts.on("-I directory", "Specify include path") do |x|
		options[:I].push x
	end

	opts.on("-o outfile", "Specify outfile") do |x|
		options[:o] = x
	end

	opts.on("-O level", OptionParser::DecimalInteger, "Specify optimization level") do |x|
		if x < 0 || x > 2
			warn "Invalid optimization level #{x}"
		else
			header.push "#pragma optimize #{x},2"
		end
	end

	opts.on("-S", "Detokenize generated code") do
		options[:S] = true
	end

	opts.on("-v", "--verbose", "Be verbose") do
		options[:verbose] = true
		header.push "#pragma progress 1"
		header.push "#pragma summary 1"
		header.push "#pragma xref 1,1"
	end

	opts.on('-V', "--version", "Display version") do
		puts opts.ver
		exit 0
	end


	opts.on("--[no-]declare", "Require declarations") do |x|
		header.push "#pragma declare #{x ? 1 : 0}"
	end

	opts.on("--[no-]progress", "Print progress") do |x|
		header.push "#pragma progress #{x ? 1 : 0}"
	end

	opts.on("--[no-]summary", "Print summary") do |x|
		header.push "#pragma summary #{x ? 1 : 0}"
	end

	opts.on("--[no-]xref", "Print Cross References") do |x|
		header.push "#pragma xref #{x ? 1 : 0},#{x ? 1 : 0}"
	end


	opts.on_tail("-h", "--help", "Display help information") do
		puts opts
		exit 0
	end


end

begin
	op.parse!
rescue OptionParser::ParseError => e
	puts e
	puts op
	exit 1
end

if ARGV.length > 1
	puts op.banner
	exit 1
end

argf_each {|infile, io|

	errors = process(infile, io, header, body)

	exit if errors > 0

	outfile = nil
	outfile = case options[:o]
	when nil ; nil
	when '-' ; $stdout
	else File.open(options[:o], "w")
	end

	if (infile == nil) && (outfile == nil)
		options[:S] = true
	end


	efile = nil
	if options[:E]
		efile = outfile || $stdout
	else
		efile = Tempfile.new(['md','.b'], '/tmp')
	end

	build_kludge(efile, header, body)

	if options[:E]
		close efile unless efile == $stdout
		exit 0
	end


	bfile = nil
	tmpfile = nil

	if options[:S]
		tmpfile = Tempfile.new(['md', '.bas'], '/tmp')
		bfile = tmpfile.path
	else
		bfile = outfile || replace_ext(infile, 'bas')
	end

	args = ['iix', 'mdbasic', efile.path, '-o', bfile]
	pid = Process.spawn(*args)
	Process.wait(pid)
	if $?.exitstatus > 0
		$stderr.puts "mdbasic++: compile #{infile} failed."
		exit 1
	end

	if options[:S]
		o = {}
		o[:out] = outfile if outfile
		args = ['iix', 'blist', bfile]
		pid = Process.spawn(*args, o)
		Process.wait(pid)
		# $?.exitstatus not currently correct.
	end


}

exit 0

